# `snowflake-ml`

## Snowflake Machine Learning

The machine learning client library that is used for interacting with Snowflake to build machine learning solutions. Functionalities include model uploading, training, feature engineering, etc.

## Build system

We are using `bazel` as the build system.

### Installation

#### Bazel

Follow the instructions [here](https://snowflakecomputing.atlassian.net/wiki/spaces/EN/pages/2547778109/Bazel+for+XP#Installing-Bazelisk) for installing bazel. Inlining some portions:

```
# This installs bazelisk in ~/go/bin/bazelisk
go install github.com/bazelbuild/bazelisk@latest
```

Add shortcut in your `~/.bashrc` (or equivalent):

```
if [ -f ~/go/bin/bazelisk ]; then
  alias bazel=~/go/bin/bazelisk
fi
```

#### Buildifier

This tool helps auto-formatting `BUILD.bazel` file. Installation is similar:

```
go install github.com/bazelbuild/buildtools/buildifier@latest
```

Add shortcut in your `~/.bashrc` (or equivalent):

```
if [ -f ~/go/bin/buildifier ]; then
  alias buildifier=~/go/bin/buildifier
fi
```

Note: You may need to configure your editor to run this on save.

### Define Library, Binary & Test explicitly

`Bazel` requires every target (library, binary or test) to be explicitly defined in a file called `BUILD.bazel` co-locating with your code. An example can be found in [utils](snowflake/ml/utils/BUILD.bazel) directory.

```python
# Loads definition of py_library from bazel directory.
load("//bazel:py_rules.bzl", "py_library", "py_binary", "py_test")

# Make sure every other library can use it. It can be different when
# we want to restrict access. Like code inside
# `transformer/internal` can not be used by anyone else outside of
# `transformer`.
package(default_visibility = ["//visibility:public"])

# Define a library
py_library(
    name = "connection_params",
    srcs = ["connection_params.py"],
)

# Define a binary
py_library(
    name = "demo",
    srcs = ["demo.py"],
    deps = [
        ":connection_params",  # local so relative path works
        "//snowflake/ml/workflow:task",  # absolute path
    ]
)

# Define a test (yes you can define locally, even though we putting
# them under //tests/...).
py_test(
    name = "connection_params_test",
    srcs = [
        "connection_params_test.py",
    ],
    deps = [
        ":connection_params",
    ]
)
```

Every directory containing a `BUILD.bazel` file is considered a package or sub-package. Importing the `connection_params` library can be done from anywhere as:

```python
from snowflake.ml.utils import connection_params
```

### Build

To build any target (library, binary or test), one can do:

```shell
> bazel build <target>
```

Where `<target>` can be of the form: `//snowflake/ml/utils:demo`, and `demo` is defined in the `BUILD.bazel` file inside `//snowflake/ml/utils`.

`bazel` can be run from anywhere under the monorepo (anywhere under `snowml`). It can accept absolute path or a relative path. For example, following two are same:

```shell
snowml> bazel build //snowflake/ml/transformer:demo
```

and

```shell
snowml/snowflake/ml> bazel test transformer:demo
```

One can build an entire sub-tree as:

```shell
snowml> bazel build //snowflake/...
```

See all possible options [here](https://bazel.build/run/build#specifying-build-targets).

### Type-check

#### mypy

We use [mypy](https://mypy.readthedocs.io/en/stable/) to type-check our Python source files. mypy is integrated into our bazel environment.

The version of MyPy is specified in `conda-env-snowflake.yml`, just like other conda
packages we depend on.

#### Invoke MyPy locally

```
bazel build --config=typecheck <your target>
```

#### Enforcement as a merge gate

Type checking is not enforced against targets listed in `ci/type_ignored_targets`.

### Test

Similar to `bazel build`, `bazel test` can test any target. The target must be
a test target. It will run the target and report if `PASSED` or `FAILED`. It essentially `build`s the target and then `run` it. You can also build and run separately.

TIP: If a test fails, there will be a log file, which is executable. You do not need to open via `less` or `editor`. You can directly paste the path in command line.

### Coverage

A `lcov` coverage report can be generated by running

```
bazel coverage --combined_report=lcov <target pattern>
```

To get a human-readable report:

```
lcov --list $(bazel info output_path)/_coverage/_coverage_report.dat
```

To get an HTML report:

```
genhtml --output <output_dir> "$(bazel info output_path)/_coverage/_coverage_report.dat"
```

Both `lcov` and `genhtml` are part of the [`lcov`](https://github.com/linux-test-project/lcov) project. To install it on MacOS:

```
brew install lcov
```

The unit test coverage report is generated periodically by a GitHub
[workflow](https://github.com/snowflakedb/snowml/actions/workflows/continuous_build.yml?query=branch%3Amain).
You can download the report in the artifacts generated by the action runs.

### Run

Another useful command is, `bazel run`. This builds and then run the built target directly. Useful for binaries while debugging.

### Other commands

`bazel` is pretty powerful and has lots of other commands. Read more [here](https://bazel.build/run/build).

### Python dependencies

To introduce a third-party Python dependency, first check if it is available as a package in the
[Snowflake conda channel](https://repo.anaconda.com/pkgs/snowflake/). If so, add the package
to [conda-env-snowflake.yml](https://github.com/snowflakedb/snowml/blob/main/conda-env-snowflake.yml),
and run the following to re-generate
[conda-env.yml](https://github.com/snowflakedb/snowml/blob/main/conda-env.yml):

```
bazel build //bazel:conda-env.yml && cp bazel-bin/bazel/conda-env.yml .
```

Then, your code can use the package as if it were "installed" in the Python environment.

#### Introduce a third-party Python dependency not available in the Snowflake channel

First, make sure you want to bring in that dependency, because that will make your code unable to
run inside UDF, UDTF or Stored Precedures, and it cannot be included in any of our packages that
need to support running in those environments.

Then, proceed with the following steps:

1. File a JIRA ticket to request your package to be added to the Snowflake conda channel.
   - See https://snowflakecomputing.atlassian.net/browse/SNOW-619992 for examples.
1. Add the package to
   [conda-env-extended.yml](https://github.com/snowflakedb/snowml/blob/main/conda-env-extended.yml).
   - Annotate your package with the JIRA ticket number.
1. Re-generate [conda-env.yml](https://github.com/snowflakedb/snowml/blob/main/conda-env.yml).
1. For any library / binary / test that uses the package, set `compatible_with_snowpark=False`
   when defining their BUILD targets, for example:
   ```
   py_library(
     name="my_lib",
     srcs = ["my_lib.py"],
     compatible_with_snowpark=False
   )
   ```
   - Fail to do so will result in merge gate failures, because we will exercise your code in
     an environment where only packages in conda-env-snowflake.yml are available.
   - Your library cannot be depended by any libraries that are included in our packages that
     need to support running in the Snowpark environments. If such a dependency is established,
     you will find a merge gate failure.
   - You can reproduce the merge gate failures by passing
     `--platforms=//bazel/platforms:snowflake_conda_env` to `bazel build|test|run`.

To understand the mechanisms under the hood, here are some leads:

- [bazel/py_rules.bzl](https://github.com/snowflakedb/snowml/blob/main/bazel/py_rules.bzl)
  (see the file-level docstring)
- [WORKSPACE](https://github.com/snowflakedb/snowml/blob/main/WORKSPACE)
  (see the comments where the conda toolchains are created)
- https://bazel.build/extending/platforms

## Unit Testing

Write `pytest` or Python `unittest` style unit tests.

### `unittest`

Use `absl.testing.absltest` as a drop-in replacement of `unittest`.

For example:

```
# instead of
# import unittest
from absl.testing import absltest

# instead of
# from unittest import TestCase, main
from absl.testing.absltest import TestCase, main
```

`absltest` provides better `bazel` integration which produces a more detailed XML
test report. The test report is picked up by a Github workflow to provide a nice UI
for test results.

### `pytest`

Make each unit test file its own runnable `py_test` target and use the `main()`
function provided by `snowflake.ml.utils.pytest_driver`.

For example:

```
from snowflake.ml.utils import pytest_driver

def test_case():
    assert some_feature()

if __name__ == "__main__":
    pytest_driver.main()
```

`pytest_driver` contains `bazel` integration that allows `pytest` to produce a XML
test report.

## `pre-commit`

Pull requests against the main branch are subject to `pre-commit` checks. Those checks enforce the code style.

You can make sure the checks can pass by installing the `pre-commit` hooks to your local repo
([instructions](https://pre-commit.com/#installation)). Those hooks will be invoked when you commit locally,
and they fix the style violations in-place.

Tip: if you want to isolate those fixes, avoid the `-a` the option in `git commit`. This way the automated changes
will be unstaged changes.

### Darglint

The [darglint](https://github.com/terrencepreilly/darglint) pre-commit hook lints docstrings to make sure they
conform to the [Google style guide for docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings).
Function docstrings must contain "Args" section with input value descriptions, "Returns" section describing output, and
"Raises" section enumerating the exceptions that the function can raise. Darglint will ensure that all input args are present
in the docstring and is sensitive to whitespace (e.g. args should be indented the correct number of spaces). Refer
to the list of [darglint error codes](https://github.com/terrencepreilly/darglint#error-codes) for guidance.

## Editors

### VSCode

Here are few good plugins to use:

1. [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python)
1. [Pylance static checking](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance)
1. [Bazel](https://marketplace.visualstudio.com/items?itemName=BazelBuild.vscode-bazel)
   - You need to configure `buildifier` in settings for auto-formatting `BUILD.bazel` files
1. [Black Python Formatter](https://marketplace.visualstudio.com/items?itemName=ms-python.black-formatter)
1. [Flake8 Linter](https://marketplace.visualstudio.com/items?itemName=ms-python.flake8)

## Other READMEs

- [CI and Jenkins](ci/README.md)
